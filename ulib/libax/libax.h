/* Generated by cbindgen and build.rs, DO NOT edit! */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Sets the seed for the random number generator.
 */
void ax_srand(uint32_t seed);

/**
 * Returns a 32-bit unsigned pseudo random interger.
 */
uint32_t ax_rand_u32(void);

/**
 * Print a string to the global standard output stream.
 */
int ax_print_str(const char *buf, size_t count);

/**
 * Abort the current process.
 */
void ax_panic(void);

/**
 * Open a file by `filename` and insert it into the file descriptor table.
 *
 * Return its index in the file table (`fd`). Return `ENFILE` if the file
 * table overflows.
 */
int ax_open(const char *filename, int flags, mode_t mode);

/**
 * Close a file by `fd`.
 */
int ax_close(int fd);

/**
 * Set the position of the file indicated by `fd`.
 *
 * Return its position after seek.
 */
off_t ax_lseek(int fd, off_t offset, int whence);

/**
 * Read data from the file indicated by `fd`.
 *
 * Return the read size if success.
 */
ssize_t ax_read(int fd, void *buf, size_t count);

/**
 * Write data to the file indicated by `fd`.
 *
 * Return the written size if success.
 */
ssize_t ax_write(int fd, const void *buf, size_t count);

/**
 * Get the file metadata by `path` and write into `buf`.
 *
 * Return 0 if success.
 */
ssize_t ax_stat(const char *path, struct stat *buf);

/**
 * Get the metadata of the symbolic link and write into `buf`.
 *
 * Return 0 if success.
 */
ssize_t ax_lstat(const char *path, struct stat *buf);

/**
 * Get file metadata by `fd` and write into `buf`.
 *
 * Return 0 if success.
 */
ssize_t ax_fstat(int fd, struct stat *buf);

/**
 * Get the path of the current directory.
 */
char *ax_getcwd(char *buf, size_t size);

/**
 * Allocate memory and return the memory address.
 *
 * Returns 0 on failure (the current implementation does not trigger an exception)
 */
void *ax_malloc(size_t size);

/**
 * Deallocate memory.
 *
 * (WARNING) If the address to be released does not match the allocated address, an error should
 * occur, but it will NOT be checked out. This is due to the global allocator `Buddy_system`
 * (currently used) does not check the validity of address to be released.
 */
void ax_free(void *addr);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus
