## 期中汇报：调度算法综合测试

##### 致理-信计01 叶昊星 2020012718

### 进展总结
- 进一步学习了 arceos 的框架，尤其是和调度相关的部分。对系统如何进行调度的流程理解更加深刻。
- 在原有的 rr 和 fifo 基础算法之外，复现了包括 cfs, sjf, mlfq 等各调度算法。
- 在 arceos 框架中加入了新实现的各调度算法，并在 parallel 测例上用多核正确运行。
- 在 arceos 框架中根据不同的场景加入多种新的测例，对各种调度算法的**公平性**、**实时性**、**响应时间**等指标进行了综合的测试。
- 针对测试得到的指标，对这些算法性能好或坏进行了具体的分析，同时对调度算法原理有了更深入的理解
- 对新加入的测例通过文档描述设计思路和运行结果。
### 各算法参数设置

- cfs：默认情况下所有的 nice 值都是 0，此时期望是完全公平调度。
- sjf：移动平均系数默认设为 1/16，初值是 0
- mlfq：队列级数为 8，第 0 级队列分到 1 个时间片，过 100000 个时间片重置队列。同优先级抢占式调度。
- rr：MAX_TIME_SLICE=5

### 实验数据

注：如果没有特殊说明，默认在**单核**模式下测试，时间单位为 **ms**。如果 cfs 设置了 nice 值，会额外说明。

#### 实验环境

OpenSBI v1.0

arch = **riscv64**
platform = **qemu-virt-riscv**
smp = 1
build_mode = release
log_level = info



Platform Name             : riscv-virtio,qemu
Platform Features         : medeleg
Platform HART Count       : 1
Platform IPI Device       : aclint-mswi
Platform Timer Device     : aclint-mtimer @ 10000000Hz
Platform Console Device   : uart8250
Platform HSM Device       : ---
Platform Reboot Device    : sifive_test
Platform Shutdown Device  : sifive_test
Firmware Base             : 0x80000000
Firmware Size             : 252 KB
Runtime SBI Version       : 0.3

Domain0 Name              : root
Domain0 Boot HART         : 0
Domain0 HARTs             : 0*
Domain0 Region00          : 0x0000000002000000-0x000000000200ffff (I)
Domain0 Region01          : 0x0000000080000000-0x000000008003ffff ()
Domain0 Region02          : 0x0000000000000000-0xffffffffffffffff (R,W,X)
Domain0 Next Address      : 0x0000000080200000
Domain0 Next Arg1         : 0x0000000087000000
Domain0 Next Mode         : S-mode
Domain0 SysReset          : yes

Boot HART ID              : 0
Boot HART Domain          : root
Boot HART ISA             : rv64imafdcsuh
Boot HART Features        : scounteren,mcounteren,time
Boot HART PMP Count       : 16
Boot HART PMP Granularity : 4
Boot HART PMP Address Bits: 54
Boot HART MHPM Count      : 0
Boot HART MIDELEG         : 0x0000000000001666
Boot HART MEDELEG         : 0x0000000000f0b509

##### 测例 1：sched-fairness-equal

设计思路：4 个进程，每个执行 **100** 组 **用时相同的任务**，每组任务结束后主动 yield 一次，初步测试调度算法的公平性

- 用时相同：每组任务需要执行一个长度为 1000000 的循环。

|      | 进程0结束时间 | 进程1结束时间 | 进程2结束时间 | 进程3结束时间 |
| ---- | ------------- | ------------- | ------------- | ------------- |
| rr   | 1291          | 1277          | 1265          | 1253          |
| fifo | 1302          | 1282          | 1265          | 1249          |
| cfs  | 1281          | 1267          | 1241          | 1243          |
| sjf  | 1262          | 1263          | 1249          | 1235          |
| mlfq | 1226          | 1150          | 1237          | 1224          |

##### 测例 2：sched-fairness-unequal

设计思路：4 个进程，每个执行 50 组用时和进程号（0-index）加一成正比的任务，每组任务结束后主动 yield 一次，跑 2s，通过每个的计算次数，测试调度算法的公平性。

|      | 进程0运行次数 | 进程1运行次数 | 进程2运行次数 | 进程3运行次数 |
| ---- | ------------- | ------------- | ------------- | ------------- |
| rr   | 21            | 21            | 20            | 18            |
| fifo | 20            | 20            | 20            | 19            |
| cfs  | 49            | 24            | 15            | 12            |
| sjf  | 135           | 10            | 6             | 4             |
| mlfq | 76            | 37            | 9             | 2             |

可以看出：

- cfs 各进程的运行次数和进程号加一大致成反比，具有良好的公平性
- sjf 公平性非常差，另外几个进程没有获得太多次运行的机会，全被进程 0 抢走了。这里另外几个进程也有运行次数的原因是，设置了预期时间初值是 0，且移动平均的系数较小（1/16），还是给了另外几个进程少量运行的机会。
- fifo 调度次数和任务负载无关。
- rr 这里由于每个循环的量较小（学习代码得知目前的实现是 10ms 一个时间片），所有的进程都落在 5 个时间片中，所以退化成了 fifo。
  - 进一步加大5倍循环量并设为5秒测试：分别是 17, 11, 8, 6，此时符合预期。

- mlfq 进程号大的较早就到了下一个优先级。两个进程工作量没差太多会落在同一个级别，一开始层内 fifo 调度，因为性能波动，工作量较大的那个有更大概率会波动到下一个优先级导致被较小的那个抢占，所以会出现不完全抢占现象。

##### 测例 3：sched-yield-speed

设计思路：4 个进程，每个执行 100000 组用时固定的任务（100次循环），每组任务结束后主动 yield 一次。

这个测例可以测试调度算法的基础速度，以及一定程度上反映公平性

|      | 进程0运行时间 | 进程1运行时间 | 进程2运行时间 | 进程3运行时间 |
| ---- | ------------- | ------------- | ------------- | ------------- |
| fifo | 281           | 280           | 280           | 279           |
| rr   | 425           | 424           | 423           | 423           |
| cfs  | 448           | 453           | 436           | 434           |
| sjf  | 466           | 245           | 120           | 371           |
| mlfq | 290           | 301           | 253           | 297           |

可以看出：

- 速度：fifo > mlfq >> rr > cfs ~ sjf。fifo 的计算最简单，调度速度最快。mlfq 当任务很短的时候几乎没啥计算。cfs 和 sfj 都需要优先队列，调度速度略慢。
- 公平性：这里 fifo, rr, cfs 表现得较为公平，sjf 由于波动会导致这些任务跑得不一样快，结果一开始波动到最快的任务抢占了队列，且由于移动平均权重设得较小（当前占 1/16），导致这个不公平进行了累积，导致了最后一个一个进程跑。mlfq 有一点不公平，原因是性能波动导致的有些进程早点进入下一级优先级，被抢占了一段时间，所以最后还需要一段时间跑。

##### 测例 4：sched-realtime

设计思路：有 4 个短任务，yield 次数分别是 500000,100000,200000，500000，循环长度分别是 10, 5, 2, 1。有一个长任务，yield 次数 8，循环长度 100000000。

- 注：对于所有调度器来说 yield 都较慢，不要直接用 yield 次数 乘以 循环长度估算时间。实际上长任务的运行时间约为所有短任务之和的两倍。

|      | 长任务完成时间 | 短任务1完成时间 | 短任务2完成时间 | 短任务3完成时间 | 短任务4完成时间 |
| ---- | -------------- | --------------- | --------------- | --------------- | --------------- |
| rr   | 2031           | 2143            | 2275            | 2432            | 2619            |
| fifo | 2012           | 1856            | 1924            | 2014            | 2100            |
| cfs  | 2805           | 168             | 311             | 496             | 1038            |
| sjf  | 2742           | 630             | 719             | 588             | 422             |
| mlfq | 2399           | 381             | 440             | 523             | 623             |

（不同的算法本身有速度差距，下面的分析已考虑到这一点）

可以看出：

- rr 和 fifo 实时性很差，rr 的短任务的结束时间远远晚于长任务结束时间，fifo 的短任务结束时间和长任务结束时间近似。
- cfs 忠实地按照公平分配原则。由于 yield 实际上相比不超过 10 次的循环占主要时间，所以几个短任务的时间大致和 yield 次数成正比（其实预期也不完全是正比，推一下式子本来就是大致正比）。得到了较好的实时性。
- sjf 按照谁快谁先的原则，因为这几个论速度差不多快，所以最早结束的短任务时间略晚于 cfs。不过短任务总的结束时间比 cfs 早，体现了较好的实时性。
- mlfq 短任务会有更高的优先级，抢占式调度，有较好的实时性。

##### 测例 5：sched-occupy

设计思路：有 2 个短进程，运行很多次；有一个长进程，运行 80 次，每次 10000000 长度的循环。测试长进程什么时候结束，反映在有实时任务的情况下的**响应时间**。

|      | 长任务完成时间 |
| ---- | -------------- |
| rr   | 2023           |
| fifo | 2019           |
| cfs  | 4828           |
| sjf  | 6740           |
| mlfq | 5416           |

可以看出：rr 和 fifo 响应时间短，cfs 响应时间一般，sjf 响应时间长。

- 这里 mlfq 的响应时间也很长，这和时间片大小和重置时间大小有关系。



**多核结果：**

用 mlfq 为例子。在 fairness-equal 测例中，单核使用1302ms，四核使用434ms，结果均正确。目前的实现能支持多核。



结论：rr和时间片尺度关系很大，时间片尺度越小公平性越好，而且实时性不行；fifo 实时性和公平性都不太好；cfs 公平性最优，实时性还可以；sjf 实时性最优，公平性不行；mlfq 实时性挺好，公平性不行但比 sjf 略好一点。

