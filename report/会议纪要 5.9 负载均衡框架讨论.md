### 框架

- 最终目标：
  - 第一步：多队列调度，能够组合之前的一些单队列调度模块。
  - 第二步：设计并实现测例（具体见“测例”模块）
  - 第三步（如果已完成前两步）：不同的核使用不同的调度算法
  - 任老师说把多队列CFS实现完就很有挑战了。这个多队列CFS和多队列 loadbalance+每个队列的调度算法用 CFS 实现，这两个是不同的东西。比如，CFS 的线程迁移需要修改 vruntime 这些东西。目前不对这两个做区分，都实现成“多队列调度，能够组合之前的一些单队列调度模块”。

- 具体对应到 arceos 上的实现：
  - 1. 对 loadbalance 实现一个新的 crate，
       1. 每个存储自己队列的 weight 信息
       2. 定义 find_target_cpu 和 thread_steal 的方法。
    2. 每个核定义一个 loadbalance 实例。
    3. 每次 spawn, block, unblock 等执行进程操作的时候，需要维护 loadbalance 的一些状态。
    4. 每次 spawn, unblock 等执行进程添加/重添加操作的时候，需要先访问 loadbalance，由 find_target_cpu 来决定给哪个 AxRunqueue，然后在 AxRunqueue 定义这个线程的调度。相当于在 AxRunqueue 外面包一层 loadbalance。这部分参考 Zircon 的 FindTargetCPU 的实现。
    5. 每次出现线程结束事件的时候，需要考虑线程窃取 thread_steal 。（这部分参考 Zircon 的线程窃取实现，但实际写法会有些不同，比如 Zircon 中的跨节点这些不会实现，Zircon 中会对 deadline 和 Fair 队列分别处理，这里实现成是对选择的那种 Scheduler 进行操作）。 
    6. 亲和掩码简化固定为全 1，且不考虑非活动 CPU。

### 测例

- 多个进程同时唤醒，比如 10000 个线程同时在 10s 的时候唤醒，看什么时候全部唤醒完成。希望能体现多队列的优势。
- 生成多个进程，过一段时间后监控每个核上的进程数量是否大致相同。测试 loadbalance 是否合理分配不同进程。
  - 多个相同的进程，看 find_target_cpu 的实现。
  - 随机负载的进程，看 thread_steal 的方法。
- I/O 密集和计算密集混合测例，可以通过调控比例来控制两种的数量。测试在“真实”环境中多队列是否能比单队列优秀。
  - 一个问题：见问题。多队列可能不一定比单队列快。
  - 指标：吞吐率（没有实现真的 I/O 可能有点问题）、实时性（指标待设计）。
    - 测量吞吐率-延迟曲线 throughput-latency
    - 客户端每秒 x 个请求，增大 x 看曲线的变化。
    - httpserver 轮询 IO 可能体现不出调度算法

### 问题

- IO设备中断的事情助教说不太来得及做。助教提出用 sleep 作为替代的方法，但是我认为 sleep 无法体现磁盘空闲（如一秒一个写操作）和忙碌（如一秒10^8个写操作）的延迟区别。请教一下是否可以用 sleep 进行替代，绕开设备中断？
- 如果最后实现正确，但测例测出来是多队列不比单队列有效，怎么处理，期末是否能看工作量而不是性能加速比进行评价？



